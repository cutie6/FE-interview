# 模块化

## 为什么要模块化/模块化的背景

Javascript 程序本来很小。但现在我们有了运行大量 Javascript 脚本的复杂程序。因此有必要开始考虑提供一种将 Javascript 程序拆分为可按需导入的单独模块的机制。Node.js 已经提供这个能力很长时间了，还有很多的 Javascript 库和框架已经开始了模块化的使用（例如，CommonJS 和基于 AMD 的其他模块系统如 RequireJS，以及最新的 Webpack 和 Babel）。

https://segmentfault.com/a/1190000010913832

## 简单的模块化方式

### 对象写法

把模块写成一个对象，所有的模块成员都放到这个对象里面。使用的时候，就是调用这个对象的属性。
这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。

### 立即执行函数写法

使用"立即执行函数"（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的

## 主流模块规范

### CommonJs

node 编程中最重要的思想之一就是模块，这个思想让 JavaScript 的大规模工程成为可能。服务端使用 CommonJS 模块规范。

在 CommonJS 中，有一个全局性方法 require()，用于加载模块。

正是由于 CommonJS 使用的 require 方式的推动，才有了后面的 AMD、CMD 也采用的 require 方式来引用模块的风格。

**弊端**
**Common.js 是同步加载的。**
**Common.js 起源于 node，在服务端广泛使用。在服务端，所有的模块都存放在本地硬盘，可以同步加载完成，等待的时间就是硬盘读取的时间。但是对于浏览器这是一个大问题，因为模块都放在服务器端，等待的时间取决于网速的快慢与模块的大小，可能要等很长时间，浏览器处于“假死”状态。**
**因此，浏览器端的模块不能采用“同步加载”，只能采用“异步加载”。这是 AMD 规范诞生的背景。**

### AMD 规范

AMD 是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

模块必须采用特定的 define()函数来定义。

```js
define(id?, dependencies?, factory)
```

目前，主要有两个 Javascript 库实现了 AMD 规范：require.js 和 curl.js。

### CMD 规范

CMD (Common Module Definition), 是 seajs 推崇的规范，CMD 则是依赖就近，用的时候再 require。

CMD 与 AMD 一样，也是采用特定的 define()函数来定义,用 require 方式来引用模块

```js
define(id?, dependencies?, factory)
```

### CMD 与 AMD 区别

AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。

AMD 依赖前置，js 可以方便知道依赖模块是谁，立即加载；

而 CMD 依赖就近，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病 CMD 的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。

## 现阶段的标准

ES6 标准发布后，module 成为标准，标准使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，我们依然采用的是 CommonJS 规范，使用 require 引入模块，使用 module.exports 导出接口。

### import 引入模块

import 语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。

import 模块导入与 export 模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。

注意:
import 必须放在文件的最开始.**import 命令是编译阶段执行的**，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。**import 命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以 import 中不能含有表达式或者变量,因此无法实现动态加载**.
因此，import 和 export 命令只能在模块的顶层，不能在代码块之中（比如，在 if 代码块之中，或在函数之中）。
这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。**在语法上，条件加载就不可能实现**。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为**require 是运行时加载模块，import 命令无法取代 require 的动态加载功能**。

### ES6 模块与 CommonJS 模块的差异

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，**原始值变了，import 加载的值也会跟着变**。因此，**ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。